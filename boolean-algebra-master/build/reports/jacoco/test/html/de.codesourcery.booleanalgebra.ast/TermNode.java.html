<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TermNode.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">boolean-algebra</a> &gt; <a href="index.source.html" class="el_package">de.codesourcery.booleanalgebra.ast</a> &gt; <span class="el_source">TermNode.java</span></div><h1>TermNode.java</h1><pre class="source lang-java linenums">package de.codesourcery.booleanalgebra.ast;

import java.util.Stack;

import de.codesourcery.booleanalgebra.IExpressionContext;
import de.codesourcery.booleanalgebra.exceptions.ParseException;
import de.codesourcery.booleanalgebra.lexer.ILexer;
import de.codesourcery.booleanalgebra.lexer.Token;
import de.codesourcery.booleanalgebra.lexer.TokenType;

public class TermNode extends ASTNode
{
<span class="nc" id="L13">    private boolean artificial = false;</span>
    
    @Override
    protected int getMaxSupportedChildCount()
    {
<span class="nc" id="L18">        return 1;</span>
    }
    
    public TermNode() {
<span class="nc" id="L22">    	super();</span>
<span class="nc" id="L23">    }</span>
    
    /**
     * INTERNAL USE ONLY.
     * 
     * @param artificial  &lt;code&gt;true&lt;/code&gt; this term node was generated by the parser to group a parsed sub-expression
     * , &lt;code&gt;false&lt;/code&gt; if the user passed an expression that contained parens
     */
<span class="nc" id="L31">    private TermNode(boolean artificial) {</span>
<span class="nc" id="L32">        this.artificial=artificial;</span>
<span class="nc" id="L33">    }    </span>
    
    private void markAsArtifical() {
<span class="nc" id="L36">        this.artificial = true;</span>
<span class="nc" id="L37">    }</span>
    
    private boolean isArtificial() {
<span class="nc" id="L40">        return artificial;</span>
    }
    
    public TermNode(ASTNode child) {
<span class="nc" id="L44">    	super( child );</span>
<span class="nc" id="L45">    }</span>
    
    protected class Operator 
    {
        private final OperatorType type;

        public Operator(OperatorType type)
<span class="nc" id="L52">        {</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">            if (type == null) {</span>
<span class="nc" id="L54">                throw new IllegalArgumentException(&quot;type must not be NULL.&quot;);</span>
            }
<span class="nc" id="L56">            this.type = type;</span>
<span class="nc" id="L57">        }</span>
        
        public OperatorType getType()
        {
<span class="nc" id="L61">            return type;</span>
        }
        
        public boolean isNOT() {
<span class="nc bnc" id="L65" title="All 2 branches missed.">            return type == OperatorType.NOT;</span>
        }
        
        public boolean isAND() {
<span class="nc bnc" id="L69" title="All 2 branches missed.">            return type == OperatorType.AND;</span>
        }
        
        public boolean isOR() {
<span class="nc bnc" id="L73" title="All 2 branches missed.">            return type == OperatorType.OR;</span>
        }        
    }
    
<span class="nc" id="L77">    protected enum ValueType {</span>
<span class="nc" id="L78">        TRUE,</span>
<span class="nc" id="L79">        FALSE,</span>
<span class="nc" id="L80">        IDENTIFIER,</span>
<span class="nc" id="L81">        TERM;</span>
    }
    
    public class Value {
        
        private final ValueType type;
        private final Object value;

        public Value(ValueType type,Object value)
<span class="nc" id="L90">        {</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">            if ( type == null ) {</span>
<span class="nc" id="L92">                throw new IllegalArgumentException(&quot;type must not be NULL.&quot;);</span>
            }
<span class="nc bnc" id="L94" title="All 2 branches missed.">            if ( value == null ) {</span>
<span class="nc" id="L95">                throw new IllegalArgumentException(&quot;value must not be NULL.&quot;);</span>
            }
<span class="nc" id="L97">            this.type = type;</span>
<span class="nc" id="L98">            this.value = value;</span>
<span class="nc" id="L99">        }</span>
        
        public ValueType getType()
        {
<span class="nc" id="L103">            return type;</span>
        }
        
        public Object getValue()
        {
<span class="nc" id="L108">            return value;</span>
        }
    }
    
    @Override    
    public ASTNode parse(ILexer lexer) throws ParseException
    {
<span class="nc" id="L115">        ASTNode result = internalParse(lexer);</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">        if ( result.hasChildren() ) {</span>
<span class="nc" id="L117">            return result.child(0);</span>
        }
<span class="nc" id="L119">        return result;</span>
    }
    
    protected ASTNode internalParse(ILexer lexer) throws ParseException
    {
        /*
         * CHARACTERS,
         */

        /*
         *  -- terminals
         *  
         * TRUE := 'true'
         * FALSE := 'false'
         * IDENTIFIER := '_\\-0-9a-zA-Z'
         * EQUALS := '='
         * NOT := 'not'
         * OR := 'or'
         * AND := 'and'
         * 
         * --- 
         * NOT_TERM = NOT TERM
         * OR_TERM = EXPR OR TERM
         * AND_TERM = EXPR AND TERM
         * 
         *  TERM = IDENTIFIER | TRUE | FALSE | NOT_TERM | OR_TERM | AND_TERM | '(' TERM ')'
         *  
         *  EXPRESSION = TERM EQUALS TERM 
         */
        
<span class="nc" id="L149">        final int startOffset = lexer.currentParseOffset();</span>
<span class="nc" id="L150">        ASTNode lastAddedNode = null;</span>
<span class="nc" id="L151">        final Stack&lt;OperatorNode&gt; operatorStack = new Stack&lt;OperatorNode&gt;();</span>
<span class="nc" id="L152">        final Stack&lt;ASTNode&gt; valueStack = new Stack&lt;ASTNode&gt;();   </span>
        
        // System.out.println(&quot; ---------- start: parse term ---------- &quot;);
        do {
<span class="nc" id="L156">            final Token tok = lexer.peek();</span>
            
<span class="nc bnc" id="L158" title="All 2 branches missed.">            if ( tok.hasType( TokenType.IDENTIFIER ) ) </span>
            {
<span class="nc" id="L160">                lastAddedNode = pushToStack( operatorStack , valueStack , new IdentifierNode().parse(lexer ) , lastAddedNode  );</span>
            } 
<span class="nc bnc" id="L162" title="All 2 branches missed.">            else if ( tok.hasType( TokenType.TRUE ) ) </span>
            {
<span class="nc" id="L164">                lastAddedNode = pushToStack( operatorStack , valueStack , new TrueNode().parse(lexer ) , lastAddedNode  );</span>
            } 
<span class="nc bnc" id="L166" title="All 2 branches missed.">            else if ( tok.hasType( TokenType.FALSE ) ) </span>
            {
<span class="nc" id="L168">                lastAddedNode = pushToStack( operatorStack , valueStack , new FalseNode().parse(lexer ) , lastAddedNode );</span>
            } 
<span class="nc bnc" id="L170" title="All 6 branches missed.">            else if ( tok.hasType( TokenType.AND ) || tok.hasType( TokenType.NOT ) || tok.hasType( TokenType.OR)) </span>
            {
<span class="nc" id="L172">                lastAddedNode = pushToStack( operatorStack ,valueStack ,  new OperatorNode().parse(lexer ) , lastAddedNode );</span>
            } 
<span class="nc bnc" id="L174" title="All 2 branches missed.">            else if ( tok.hasType( TokenType.PARENS_OPEN ) ) </span>
            {
<span class="nc" id="L176">                lexer.read( TokenType.PARENS_OPEN );</span>
<span class="nc" id="L177">                ASTNode parsed = new TermNode().internalParse(lexer);</span>
<span class="nc" id="L178">                lastAddedNode = pushToStack( operatorStack ,valueStack , parsed , lastAddedNode  );</span>
<span class="nc" id="L179">                lexer.read( TokenType.PARENS_CLOSE);                </span>
            }
            else {
                break;
            }
            
<span class="nc bnc" id="L185" title="All 2 branches missed.">        } while ( ! lexer.eof() );</span>

<span class="nc" id="L187">        clearStacks( operatorStack , valueStack , lastAddedNode );</span>

<span class="nc bnc" id="L189" title="All 2 branches missed.">        if ( ! operatorStack.isEmpty() ) {</span>
<span class="nc" id="L190">            throw new ParseException(&quot;Term stack not empty: &quot;+operatorStack, startOffset );</span>
        }
        // System.out.println(&quot; ---------- finish: parse term : &quot;+this+&quot; ---------- &quot;);
        
<span class="nc" id="L194">        assertNoEmptyTerms( startOffset );</span>
<span class="nc" id="L195">        return this;</span>
    }
    
    private void assertNoEmptyTerms(final int offset) {
<span class="nc" id="L199">        final INodeVisitor visitor = new INodeVisitor() {</span>
            
            @Override
            public boolean visit(ASTNode node, int currentDepth)
            {
<span class="nc bnc" id="L204" title="All 4 branches missed.">                if ( node instanceof TermNode &amp;&amp; ! node.hasChildren() ) {</span>
<span class="nc" id="L205">                    throw new ParseException(&quot;Term must not be empty&quot;,offset);                    </span>
                }
<span class="nc" id="L207">                return true;</span>
            }
        };
<span class="nc" id="L210">        visitInOrder( visitor );</span>
<span class="nc" id="L211">    }</span>

    private void clearStacks(Stack&lt;OperatorNode&gt; operatorStack, Stack&lt;ASTNode&gt; valueStack, ASTNode lastAddedNode)
    {
<span class="nc bnc" id="L215" title="All 4 branches missed.">        if ( operatorStack.isEmpty() &amp;&amp; valueStack.size() == 1 ) </span>
        {
<span class="nc" id="L217">            final ASTNode value = valueStack.pop();</span>
            // System.out.println(&quot;VALUE: POP &quot;+value);
<span class="nc bnc" id="L219" title="All 2 branches missed.">            if ( lastAddedNode != null ) {</span>
<span class="nc" id="L220">                lastAddedNode.addChild( value );</span>
            } else {
<span class="nc" id="L222">                addChild( value );</span>
            }
<span class="nc" id="L224">            return;</span>
        }
        
<span class="nc" id="L227">        ASTNode previousNode = lastAddedNode;</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">        while( ! operatorStack.isEmpty() ) </span>
        {
<span class="nc" id="L230">            previousNode = popOperatorFromStack(operatorStack, valueStack, previousNode,true);</span>
        }
        
<span class="nc bnc" id="L233" title="All 2 branches missed.">        if ( ! valueStack.isEmpty() ) {</span>
<span class="nc" id="L234">            throw new RuntimeException(&quot;Internal error, value stack not empty: &quot;+valueStack);</span>
        }
        
        // System.out.println(&quot; ---------- finish: clearing stacks ----------&quot;);          
<span class="nc" id="L238">    }</span>

    private ASTNode pushToStack(Stack&lt;OperatorNode&gt; operatorStack,Stack&lt;ASTNode&gt; valueStack,ASTNode newNode,ASTNode lastAddedNode) 
    {
<span class="nc bnc" id="L242" title="All 2 branches missed.">        if ( ! ( newNode instanceof OperatorNode ) ) {</span>
<span class="nc" id="L243">            valueStack.push( newNode );</span>
            // System.out.println(&quot;VALUE: PUSH &quot;+newNode);
<span class="nc" id="L245">            return lastAddedNode;</span>
        }
        
<span class="nc" id="L248">        final OperatorNode x = (OperatorNode) newNode;</span>
        
        /*
    For all the input tokens [S1]:

        - Read the next token [S2];
        - If token is an operator (x) [S3]:
            - While there is an operator (y) at the top of the operators stack and either (x) is
              left-associative and its precedence is less or equal to that of (y), or (x) is right-associative
              and its precedence is less than (y) [S4]:

         * Pop (y) from the stack [S5];
         * Add (y) output buffer [S6];
            - Push (x) on the stack [S7];

          Else If token is left parenthesis, then push it on the stack [S8];

          Else If token is a right parenthesis [S9]:
            Until the top token (from the stack) is left parenthesis, pop from the stack to the output buffer [S10];
            Also pop the left parenthesis but donâ€™t include it in the output buffer [S11];

          Else add token to output buffer [S12].

        - While there are still operator tokens in the stack, pop them to output [S13]
         */
        // System.out.println(&quot;CURRENT OPERATOR: &quot;+x);  
<span class="nc bnc" id="L274" title="All 2 branches missed.">        if ( ! operatorStack.isEmpty()  ) {</span>

<span class="nc" id="L276">            final OperatorNode y = operatorStack.peek();</span>
<span class="nc bnc" id="L277" title="All 4 branches missed.">            if ( ( isLeftAssociative(x) &amp;&amp; getPrecedence( x ) &lt;= getPrecedence( y ) ) ||</span>
<span class="nc bnc" id="L278" title="All 4 branches missed.">                   ( isRightAssociative(x) &amp;&amp; getPrecedence( x ) &lt; getPrecedence( y ) ) )</span>
            {
<span class="nc bnc" id="L280" title="All 2 branches missed.">            	if ( isLeftAssociative( x ) ) {</span>
            		// System.out.println(&quot;Left-associative operator &quot;+x+&quot; has &lt;= precedence than &quot;+y);            		
            	} else {
            		// System.out.println(&quot;Right-associative operator &quot;+x+&quot; has &lt; precedence than &quot;+y);
            	}
<span class="nc" id="L285">                ASTNode result = popOperatorFromStack(operatorStack, valueStack,lastAddedNode,false);</span>
                // System.out.println(&quot;OPERATOR: PUSH &quot;+x);  
<span class="nc" id="L287">                operatorStack.push( x );</span>
<span class="nc" id="L288">                return result;</span>
            } 
            // System.out.println(&quot;OPERATOR: PUSH &quot;+x);            
<span class="nc" id="L291">            operatorStack.push( x );                  </span>
<span class="nc" id="L292">        } else {</span>
            // System.out.println(&quot;OPERATOR: PUSH &quot;+x);  
<span class="nc" id="L294">            operatorStack.push( x );            </span>
        }
<span class="nc" id="L296">        return lastAddedNode;</span>
    }

    private ASTNode popOperatorFromStack(Stack&lt;OperatorNode&gt; operatorStack, 
            Stack&lt;ASTNode&gt; valueStack, 
            ASTNode lastAddedNode,
            boolean clearStack)
    {
<span class="nc" id="L304">        final OperatorNode op = operatorStack.pop();</span>
        // System.out.println(&quot;OPERATOR: POP &quot;+op);
        
        ASTNode newNode;
<span class="nc bnc" id="L308" title="All 2 branches missed.">        if ( isRightAssociative( op ) ) // NOT &lt;something&gt;</span>
        {
<span class="nc bnc" id="L310" title="All 2 branches missed.">            if ( valueStack.isEmpty() ) {</span>
<span class="nc" id="L311">                throw new ParseException(&quot;Missing operand&quot;,-1);</span>
            }
<span class="nc" id="L313">            final ASTNode rightValue = valueStack.pop();</span>
            // System.out.println(&quot;VALUE: POP &quot;+rightValue);
<span class="nc bnc" id="L315" title="All 2 branches missed.">            if ( op.isNOT() ) {</span>
<span class="nc" id="L316">                newNode = OperatorNode.not( rightValue);</span>
            } else {
<span class="nc" id="L318">                throw new RuntimeException(&quot;Internal error&quot;); </span>
            }
<span class="nc" id="L320">        } </span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">        else if ( isLeftAssociative( op ) ) // &lt;something&gt; AND &lt;something&gt;, &lt;something&gt; OR &lt;something&gt;</span>
        {
<span class="nc bnc" id="L323" title="All 2 branches missed.">            if ( valueStack.isEmpty() ) {</span>
<span class="nc" id="L324">                throw new ParseException(&quot;Missing operand&quot;,-1);</span>
            }            
<span class="nc" id="L326">            final ASTNode rightValue = valueStack.pop();</span>
            // System.out.println(&quot;VALUE: POP &quot;+rightValue);
<span class="nc bnc" id="L328" title="All 2 branches missed.">            if ( valueStack.isEmpty() ) {</span>
<span class="nc" id="L329">                throw new ParseException(&quot;Missing operand&quot;,-1);</span>
            }            
<span class="nc" id="L331">            final ASTNode leftValue = valueStack.pop();</span>
            // System.out.println(&quot;VALUE: POP &quot;+leftValue);
<span class="nc bnc" id="L333" title="All 2 branches missed.">            if ( op.isAND() ) {</span>
<span class="nc" id="L334">                newNode = OperatorNode.and( leftValue, rightValue);</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">            } else if ( op.isOR() ) {</span>
<span class="nc" id="L336">                newNode = OperatorNode.or( leftValue, rightValue);</span>
            } else {
<span class="nc" id="L338">                throw new RuntimeException(&quot;Internal error&quot;);                        </span>
            }
<span class="nc" id="L340">        } </span>
        else {
<span class="nc" id="L342">            throw new RuntimeException(&quot;Internal error , unhandled operator &quot;+op);</span>
        }
        
<span class="nc bnc" id="L345" title="All 4 branches missed.">        if ( ! operatorStack.isEmpty() || ! clearStack  ) {</span>
            // System.out.println(&quot;COMBINED VALUE: PUSH &quot;+newNode);
<span class="nc" id="L347">            valueStack.push( newNode );</span>
<span class="nc" id="L348">            return lastAddedNode;</span>
        } 
        
<span class="nc bnc" id="L351" title="All 2 branches missed.">        if ( lastAddedNode != null ) {</span>
<span class="nc" id="L352">            lastAddedNode.addChild( newNode );</span>
        } else {
<span class="nc" id="L354">            addChild( newNode );</span>
        }
<span class="nc" id="L356">        return newNode;</span>
    }

    private boolean isLeftAssociative(OperatorNode node) {
<span class="nc bnc" id="L360" title="All 4 branches missed.">        return node.isAND() || node.isOR();</span>
    }

    private boolean isRightAssociative(OperatorNode node) {
<span class="nc" id="L364">        return node.isNOT();</span>
    }

    /**
     * 
     * @param node
     * @return precedence value, the higher the returned value, the higher the node's precedence
     */
    protected int getPrecedence(OperatorNode node) {
<span class="nc" id="L373">        return node.getType().getPrecedence();</span>
    }
    
    @Override
    public String toString(boolean prettyPrint)
    {
<span class="nc bnc" id="L379" title="All 2 branches missed.">        if ( prettyPrint) {</span>
<span class="nc bnc" id="L380" title="All 4 branches missed.">            if ( ! hasParent() || getParent() instanceof BooleanExpression) { </span>
<span class="nc" id="L381">                return childToString(0 , prettyPrint );</span>
            }
        }
<span class="nc" id="L384">      	return &quot;(&quot;+childToString(0 , prettyPrint )+&quot;)&quot;;</span>
    }
    
    @Override
    public boolean hasLiteralValue(IExpressionContext context) {
<span class="nc" id="L389">    	return child(0).hasLiteralValue( context );</span>
    }
    
	@Override
	protected TermNode copyThisNode() 
	{
<span class="nc" id="L395">		return new TermNode();</span>
	}     

    @Override
	public ASTNode evaluate(IExpressionContext context)
    {
<span class="nc" id="L401">        return child(0).evaluate( context );</span>
    }

	@Override
	public boolean isEquals(ASTNode other) {
<span class="nc bnc" id="L406" title="All 2 branches missed.">		if ( other instanceof TermNode ) {</span>
<span class="nc" id="L407">			final int len = getChildCount();</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">			if ( len != other.getChildCount() ) {</span>
<span class="nc" id="L409">				return false;</span>
			}
<span class="nc bnc" id="L411" title="All 2 branches missed.">			for ( int i = 0 ; i &lt; len ; i++ ) {</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">				if ( ! child(i).isEquals( other.child(i) ) ) {</span>
<span class="nc" id="L413">					return false;</span>
				}
			}
<span class="nc" id="L416">			return true;</span>
		}
<span class="nc" id="L418">		return false;</span>
	}

    @Override
    protected int thisHashCode()
    {
<span class="nc" id="L424">        return 0x8610231f;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>