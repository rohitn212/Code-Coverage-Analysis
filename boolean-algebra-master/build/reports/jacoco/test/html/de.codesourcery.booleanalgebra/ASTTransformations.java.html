<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ASTTransformations.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">boolean-algebra</a> &gt; <a href="index.source.html" class="el_package">de.codesourcery.booleanalgebra</a> &gt; <span class="el_source">ASTTransformations.java</span></div><h1>ASTTransformations.java</h1><pre class="source lang-java linenums">package de.codesourcery.booleanalgebra;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import de.codesourcery.booleanalgebra.ast.ASTNode;
import de.codesourcery.booleanalgebra.ast.BooleanExpression;
import de.codesourcery.booleanalgebra.ast.FalseNode;
import de.codesourcery.booleanalgebra.ast.INodeMatcher;
import de.codesourcery.booleanalgebra.ast.INodeVisitor;
import de.codesourcery.booleanalgebra.ast.Identifier;
import de.codesourcery.booleanalgebra.ast.IdentifierNode;
import de.codesourcery.booleanalgebra.ast.OperatorNode;
import de.codesourcery.booleanalgebra.ast.TermNode;
import de.codesourcery.booleanalgebra.ast.TreeMatcher;
import de.codesourcery.booleanalgebra.ast.TrueNode;

<span class="fc" id="L23">public class ASTTransformations </span>
{
<span class="fc" id="L25">    private boolean debug = false;</span>

    protected interface IIterationContext 
    {
        public void stop();
        public void astMutated();
    }

    /*
Kommutativgesetze 	  =&gt; a and b = b and a 	
                      =&gt; a or b = b or a

Assoziativgesetze 	  =&gt; (a and b) and c = a and (b and c) 	
                      =&gt; (a or b) or c = a or (b or c)

[OK] Idempotenzgesetze 	  =&gt; a and a=a 	
                          =&gt; a or a=a

[OK] Distributivgesetze   =&gt; a and (b or c) = (a and b)  or (a  and c) 	
                           =&gt; a or (b and c) = (a or b)  and (a  or c)

[OK] NeutralitÃ¤tsgesetze   =&gt; a and 1 = a 	
                           =&gt; a or 0 = a

[OK] Extremalgesetze 	   =&gt; a and 0=0 	
                           =&gt; a or 1=1

[OK] Doppelnegationsgesetz =&gt; not( not a)=a

[OK] De Morgansche Gesetze =&gt; not(a and b)= not a or not b 	
                           =&gt; not(a or b)= not a and not b

[OK] KomplementÃ¤rgesetze   =&gt; a and not a=0 	
                           =&gt; a or not a=1

[OK] DualitÃ¤tsgesetze 	   =&gt; not 0 = 1 
                           =&gt; not 1 = 0

[OK] Absorptionsgesetze    =&gt; a or(a and b)=a 	
                           =&gt; a and(a or b)=a	 
     */
    public ASTNode simplify(ASTNode term,final IExpressionContext context) 
    {
<span class="nc bnc" id="L68" title="All 2 branches missed.">        if ( term instanceof BooleanExpression) </span>
        {
<span class="nc" id="L70">            final BooleanExpression expr = (BooleanExpression) term;</span>
<span class="nc" id="L71">            ASTNode left = simplifyTerm( expr.getLHS() , context );</span>
<span class="nc" id="L72">            ASTNode right = simplifyTerm( expr.getRHS() , context );</span>
<span class="nc" id="L73">            return new BooleanExpression( left , right );</span>
        } 
<span class="nc" id="L75">        return simplifyTerm( term , context );</span>
    }

    protected ASTNode simplifyTerm(ASTNode term,final IExpressionContext context) {

<span class="nc" id="L80">        debugPrintln(&quot;Simplifying &quot;+term.toString(true));</span>

<span class="nc" id="L82">        final Comparator&lt;ASTNode&gt; comp = new Comparator&lt;ASTNode&gt;() {</span>

            @Override
            public int compare(ASTNode o1, ASTNode o2) 
            {
<span class="nc bnc" id="L87" title="All 4 branches missed.">                if ( o1.isLeafNode() &amp;&amp; o2.isLeafNode() ) {</span>
<span class="nc" id="L88">                    return o2.toString().compareTo( o1.toString() );</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">                } else if ( o1.isLeafNode() ) {</span>
<span class="nc" id="L90">                    return 1;</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">                } else if ( o2.isLeafNode() ) {</span>
<span class="nc" id="L92">                    return -1;</span>
                }
<span class="nc" id="L94">                return 0;</span>
            }
        };

<span class="nc" id="L98">        ASTNode result = term.createCopy( true );</span>

<span class="nc" id="L100">        result = reduce( result , context );</span>

<span class="nc" id="L102">        int loopCounter = 0;</span>

<span class="nc" id="L104">        boolean simplified = result.sortChildrenAscending( comp );</span>
        do {
<span class="nc" id="L106">            simplified = false;</span>

            // Assoziativgesetz
            // (a and b) and c = a and (b and c) 	
            // (a or b) or c = a or (b or c)
<span class="nc" id="L111">            simplified |= applyLawOfAssociativity(context,result);</span>

            // Idempotenzgesetze:    =&gt; x and x = x 
            //                       =&gt; x or  x = x
<span class="nc" id="L115">            simplified |= applyLawOfIdemPotency(context, result);</span>

            // double negation:      =&gt; not( not a) = a
<span class="nc" id="L118">            simplified |= applyRuleOfDoubleNegation(context, result);</span>

            // NeutralitÃ¤tsgesetze  =&gt; a and 1 = a 	
            //                      =&gt; a or  0 = a
<span class="nc" id="L122">            simplified |= applyLawOfIdentity(context, result);		</span>

            // Extremalgesetze 	 =&gt; a and 0 =0 	
            //                      =&gt; a or  1 =1		 
<span class="nc" id="L126">            simplified |= applyLawOfExtrema(context, result);		</span>

            // KomplementÃ¤rgesetze   =&gt; a and not a = 0 	
            //                       =&gt; a or  not a = 1			
<span class="nc" id="L130">            simplified |= applyLawOfComplements(context, result);</span>

            // Absorptionsgesetze 	 =&gt; a or (a and b) = a 	
            //                       =&gt; a and(a or  b) = a			
<span class="nc" id="L134">            simplified |= applyLawOfAbsorption(context, result);</span>

            // Distributionsgesetz
            // 	a and (b or  c) = (a and b) or  (a and c) 	
            //  a or  (b and c) = (a or  b) and (a or  c)
<span class="nc" id="L139">            simplified |= applyDistributiveLaw(context,result);</span>

            // De Morgansche Gesetze  =&gt; not(a and b) = not a or  not b     
            //                        =&gt; not(a or  b) = not a and not b     
<span class="nc" id="L143">            simplified = applyLawOfDeMorgan(context,result);            </span>

            // De Morgansche Gesetze  =&gt; not a or  not b = not(a and b)  	
            //                        =&gt; not a and not b = not(a or  b)
            //			simplified |= applyInverseLawOfDeMorgan(context,result);		
<span class="nc" id="L148">            loopCounter++;</span>
<span class="nc bnc" id="L149" title="All 4 branches missed.">        } while ( simplified || loopCounter &lt; 2 );</span>

        // get rid of all variables we eliminated
<span class="nc" id="L152">        context.retainOnly( gatherIdentifiers( result ));</span>
<span class="nc" id="L153">        return result;</span>
    }

    public void moveToTopLevel(ASTNode nodeToMove) {

<span class="nc" id="L158">        final List&lt;ASTNode&gt; pathFromRoot = nodeToMove.getPathFromRoot();</span>
<span class="nc" id="L159">        final ASTNode root = pathFromRoot.get(0);</span>
<span class="nc bnc" id="L160" title="All 6 branches missed.">        if ( root == nodeToMove || pathFromRoot.size() == 2 &amp;&amp; pathFromRoot.get(0) instanceof TermNode) {</span>
<span class="nc" id="L161">            return; // nothing to do, already at top-level</span>
        }

        /*
         *  Task: isolate d
         *  
         * Initial term: (a or b) and (c or d) = true
         * 
         * Step 1: align associated operator (OR) with outer expression so we can re-order the AST nodes
         * 
         * =&gt; (a or b) and (not(c) and not(d) ) = true // de-morgan
         * 
         * =&gt;(a or b) and not(c) and not(d) = true
         * 
         * =&gt;  d or ( (a or b) and not(c) and not(d) )  = d or true
         * 
         * =&gt; * =&gt; AND
         *    + =&gt; OR
         *    
         *    d + ( ( a + b ) * not(c) * not(d) ) = d + true
         *    
         * =&gt; d OR (a OR b) AND (d OR NOT (c)) AND (d OR NOT (d)) = d or true
         * 
         * =&gt;  
         */

        /*
            //  a or  (b and c) = (a or  b) and (a or  c)         
         */
<span class="nc" id="L190">    }</span>

    public ASTNode substituteCommonTerms(ASTNode tree,IExpressionContext context) {

<span class="nc" id="L194">        ASTNode copy = tree.createCopy( true );</span>

<span class="nc" id="L196">        final Map&lt;Integer,List&lt;ASTNode&gt;&gt; result = new HashMap&lt;&gt;();</span>

<span class="nc" id="L198">        final INodeVisitor visitor = new INodeVisitor() {</span>

            @Override
            public boolean visit(ASTNode node, int currentDepth)
            {
<span class="nc" id="L203">                final Integer hash = node.hashCode();</span>
<span class="nc" id="L204">                List&lt;ASTNode&gt; existing = result.get( hash );</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">                if ( existing == null ) {</span>
<span class="nc" id="L206">                    existing = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L207">                    result.put( hash , existing );</span>
                }
<span class="nc" id="L209">                existing.add( node );</span>
<span class="nc" id="L210">                return true;</span>
            }
        };
<span class="nc" id="L213">        tree.visitInOrder( visitor );</span>

        outer:        
<span class="nc bnc" id="L216" title="All 2 branches missed.">            for ( Map.Entry&lt;Integer,List&lt;ASTNode&gt;&gt; entry : result.entrySet() ) </span>
            {
<span class="nc" id="L218">                final int hash = entry.getKey();</span>

<span class="nc bnc" id="L220" title="All 2 branches missed.">                if ( entry.getValue().size() &lt;= 1 )</span>
                {
<span class="nc" id="L222">                    continue;</span>
                }

<span class="nc bnc" id="L225" title="All 2 branches missed.">                for ( ASTNode n : entry.getValue() ) </span>
                {
<span class="nc bnc" id="L227" title="All 2 branches missed.">                    if ( n instanceof IdentifierNode) </span>
                    {
<span class="nc" id="L229">                        continue outer;</span>
                    }
<span class="nc" id="L231">                }</span>

                // create new variable
<span class="nc" id="L234">                final ASTNode value = entry.getValue().get(0).createCopy(true);</span>
<span class="nc" id="L235">                final Identifier identifier = context.createIdentifier( value );</span>

<span class="nc" id="L237">                final boolean substituted = replaceMatchingTermsWithVariable(context, copy, hash, identifier);</span>

<span class="nc bnc" id="L239" title="All 2 branches missed.">                if ( substituted ) {</span>
<span class="nc" id="L240">                    debugPrintln(&quot;SUBSTITUTE: &quot;+value+&quot; =&gt; &quot;+identifier+&quot; ( &quot;+entry.getValue().size()+&quot; times )&quot;);   </span>
                } else {
<span class="nc" id="L242">                    context.remove( identifier );</span>
                } 
<span class="nc" id="L244">            }</span>
<span class="nc" id="L245">        return copy;</span>
    }

    private boolean replaceMatchingTermsWithVariable(IExpressionContext context, ASTNode tree, final int hashToReplace, final Identifier identifier)
    {
<span class="nc" id="L250">        final boolean[] substituted = { false };</span>
<span class="nc" id="L251">        final MutatingNodeVisitor substitutionVisitor = new MutatingNodeVisitor( context ) {</span>

            @Override
            protected void visit(ASTNode node, IExpressionContext context, IIterationContext it)
            {
<span class="nc bnc" id="L256" title="All 4 branches missed.">                if ( node.hashCode() == hashToReplace &amp;&amp; node.hasParent() ) {</span>
<span class="nc" id="L257">                    node.replaceWith( new IdentifierNode( identifier ) );</span>
<span class="nc" id="L258">                    it.astMutated();</span>
<span class="nc" id="L259">                    substituted[0] = true;</span>
                }
<span class="nc" id="L261">            }</span>
        };
<span class="nc" id="L263">        applyPreOrder( tree , substitutionVisitor );</span>
<span class="nc" id="L264">        return substituted[0];</span>
    }

    public Boolean isTrue(BooleanExpression expr,IExpressionContext context) {

<span class="nc" id="L269">        ASTNode lhs = expr.getLHS();</span>
<span class="nc" id="L270">        ASTNode rhs = expr.getRHS();</span>

<span class="nc" id="L272">        ASTNode value1 = lhs.evaluate( context );</span>
<span class="nc" id="L273">        ASTNode value2= rhs.evaluate( context );</span>
<span class="nc bnc" id="L274" title="All 4 branches missed.">        if ( value1 != null &amp;&amp; value2 != null ) {</span>
<span class="nc" id="L275">            return value1.isEquivalent( value2 , context );</span>
        }
<span class="nc" id="L277">        return null;</span>
    }

    private boolean applyLawOfAssociativity(IExpressionContext context,
            ASTNode result) 
    {

        /*
         * Assoziativgesetz:
         * 
         * (a and b) and c = a and (b and c)    
         * (a or b) or c = a or (b or c)
         *                                
         *  ( a and b ) and a =&gt; ( a and a ) and b
         *  
         *          AND                  AND    
         *         /  \                 /  \   
         *       AND   a      =&gt;      AND   b   
         *      /   \                /   \     
         *     a     b              a     a    
         *  
         *  a and ( b and a ) =&gt; ( a and a ) and b
         *  
         *          AND               AND    
         *         /  \              /  \    
         *        a   AND     =&gt;    a   AND  
         *           /   \             /   \ 
         *          b     a           a     b          
         */

<span class="nc" id="L307">        final MutatingNodeVisitor visitor = new MutatingNodeVisitor( context ) {</span>

            @Override
            public void visit(ASTNode node,IExpressionContext context,IIterationContext it) 
            {
<span class="nc" id="L312">                final ASTNode unwrapped = unwrap( node );</span>

<span class="nc bnc" id="L314" title="All 2 branches missed.">                if ( unwrapped.hasParent()  ) </span>
                {
<span class="nc bnc" id="L316" title="All 2 branches missed.">                    if ( unwrapped.isAND() ) </span>
                    {
                        // (a and b) and c = a and (b and c) 	
<span class="nc" id="L319">                        ASTNode leftChild = unwrapped.leftChild();</span>
<span class="nc" id="L320">                        ASTNode rightChild = unwrapped.rightChild();</span>

<span class="nc bnc" id="L322" title="All 2 branches missed.">                        if ( unwrapped.isAND() &amp;&amp;</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">                                rightChild.isLeafNode() &amp;&amp; </span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">                                isNonTrivialTerm( leftChild ) &amp;&amp; </span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">                                unwrap( leftChild ).isAND() )</span>
                        {
<span class="nc" id="L327">                            ASTNode term1 = </span>
<span class="nc" id="L328">                                    new TermNode( OperatorNode.and(</span>
<span class="nc" id="L329">                                            unwrap( leftChild ).rightChild().createCopy( true ) ,</span>
<span class="nc" id="L330">                                            rightChild ).createCopy( true ) );</span>

<span class="nc" id="L332">                            ASTNode term2 = </span>
<span class="nc" id="L333">                                    OperatorNode.and( unwrap( leftChild ).leftChild().createCopy( true ) , term1 ) ;</span>

<span class="nc" id="L335">                            debugPrintln(&quot;ASSOCIATIVITY: Replacing &quot;+unwrapped.toString(false)+&quot; -&gt; &quot;+term2);</span>
<span class="nc" id="L336">                            unwrapped.replaceWith( term2 );</span>
<span class="nc" id="L337">                            it.astMutated();						</span>
                        } 
<span class="nc" id="L339">                    } </span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">                    else if ( unwrapped.isOR() ) </span>
                    {
                        // (a or b) or c = a or (b or c) 	
<span class="nc" id="L343">                        ASTNode leftChild = unwrapped.leftChild();</span>
<span class="nc" id="L344">                        ASTNode rightChild = unwrapped.rightChild();</span>

<span class="nc bnc" id="L346" title="All 2 branches missed.">                        if ( unwrapped.isOR() &amp;&amp;</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">                                rightChild.isLeafNode() &amp;&amp; </span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">                                isNonTrivialTerm( leftChild ) &amp;&amp; </span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">                                unwrap( leftChild ).isOR() )</span>
                        {
<span class="nc" id="L351">                            ASTNode term1 = </span>
<span class="nc" id="L352">                                    new TermNode( OperatorNode.or(</span>
<span class="nc" id="L353">                                            unwrap( leftChild ).rightChild().createCopy( true ) ,</span>
<span class="nc" id="L354">                                            rightChild.createCopy( true ) ) );</span>

<span class="nc" id="L356">                            ASTNode term2 = </span>
<span class="nc" id="L357">                                    OperatorNode.or( unwrap( leftChild ).leftChild().createCopy( true ) , term1 ) ;</span>

<span class="nc" id="L359">                            debugPrintln(&quot;ASSOCIATIVITY: Replacing &quot;+unwrapped.toString(false)+&quot; -&gt; &quot;+term2);</span>
<span class="nc" id="L360">                            unwrapped.replaceWith( term2 );</span>
<span class="nc" id="L361">                            it.astMutated();						</span>
                        } 

                    }
                }
<span class="nc" id="L366">            }</span>
        };
<span class="nc" id="L368">        return applyInOrder( result , visitor );</span>
    }

    private static boolean isNonTrivialTerm(ASTNode node) 
    {
<span class="nc bnc" id="L373" title="All 4 branches missed.">        return node instanceof TermNode &amp;&amp; ! node.child(0).isLeafNode();</span>
    }

    private boolean applyDistributiveLaw(IExpressionContext context,
            ASTNode result) 
    {
        // Distributionsgesetz
        // 	case 1: a and (b or  c) = (a and b) or  (a and c) 	
        //  case 2: a or  (b and c) = (a or  b) and (a or  c)

        
<span class="nc" id="L384">        final TreeMatcher matcher = new TreeMatcher().ignoreChildOrder( true ).requireNodeToHaveParent( true ).unwrapAll()</span>
<span class="nc" id="L385">                .matchParent().matchAND().matchOR().buildOR()</span>
<span class="nc" id="L386">                .matchRightChild().addMatcher( new INodeMatcher() {</span>

                    @Override
                    public boolean matches(TreeMatcher matcher, ASTNode n)
                    {
<span class="nc" id="L391">                        final ASTNode unwrapped = unwrap(matcher.parentMatch());</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">                        if ( unwrapped.isOR() ) {</span>
<span class="nc" id="L393">                            return n.isAND();</span>
                        }  
<span class="nc bnc" id="L395" title="All 2 branches missed.">                        if ( unwrapped.isAND() ) {</span>
<span class="nc" id="L396">                            return n.isOR();</span>
                        }
<span class="nc" id="L398">                        throw new RuntimeException(&quot;Unreachable code reached&quot;);</span>
                    }
<span class="nc" id="L400">                } ).buildOR()</span>
<span class="nc" id="L401">                .matchExtra().addMatcher( new INodeMatcher() {</span>

                    @Override
                    public boolean matches(TreeMatcher matcher, ASTNode n)
                    {
<span class="nc bnc" id="L406" title="All 2 branches missed.">                        return matcher.leftMatch().getNodeCount() != matcher.rightMatch().getNodeCount();</span>
                    }
<span class="nc" id="L408">                } ).buildOR();</span>
                
<span class="nc" id="L410">        final MutatingNodeVisitor visitor = new MutatingNodeVisitor( context ) {</span>

            @Override
            public void visit(ASTNode node,IExpressionContext context,IIterationContext it) 
            {
                
<span class="nc bnc" id="L416" title="All 2 branches missed.">                if ( ! matcher.matches( matcher , node ) ) {</span>
<span class="nc" id="L417">                    return;</span>
                }
                
<span class="nc" id="L420">                final ASTNode matchedParent = matcher.parentMatch();</span>
<span class="nc" id="L421">                final ASTNode leftChild = matcher.leftMatch();</span>
<span class="nc" id="L422">                final ASTNode rightChild = matcher.rightMatch();</span>
                
                final ASTNode leftTerm;
                final ASTNode rightTerm;
                final ASTNode replacementTerm;
                
<span class="nc" id="L428">                ASTNode unwrappedRight = unwrap( rightChild );</span>
<span class="nc bnc" id="L429" title="All 4 branches missed.">                if ( unwrap( matchedParent) .isAND() &amp;&amp; unwrappedRight.isOR() ) </span>
                {
<span class="nc" id="L431">                    leftTerm = maybeWrapInTerm( OperatorNode.and( leftChild , unwrappedRight.child(0) ) );</span>
<span class="nc" id="L432">                    rightTerm = maybeWrapInTerm( OperatorNode.and( leftChild , unwrappedRight.child(1) ) );</span>
<span class="nc" id="L433">                    replacementTerm = OperatorNode.or( leftTerm  , rightTerm );</span>
                } 
<span class="nc bnc" id="L435" title="All 4 branches missed.">                else if ( unwrap( matchedParent).isOR() &amp;&amp; unwrappedRight.isAND() ) </span>
                {
<span class="nc" id="L437">                    leftTerm = maybeWrapInTerm( OperatorNode.or( leftChild , unwrappedRight.child(0) ) );</span>
<span class="nc" id="L438">                    rightTerm = maybeWrapInTerm( OperatorNode.or( leftChild , unwrappedRight.child(1) ) );</span>
<span class="nc" id="L439">                    replacementTerm = OperatorNode.and( leftTerm  , rightTerm );</span>
                } else {
<span class="nc" id="L441">                    throw new RuntimeException(&quot;Unreachable code reached =&gt; &quot;+matcher);</span>
                }
                
<span class="nc" id="L444">                ASTNode toReplace = matchedParent;</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">                if ( ! toReplace.hasParent() ) </span>
                {
<span class="nc bnc" id="L447" title="All 2 branches missed.">                  if ( unwrap( toReplace ) != toReplace ) {</span>
<span class="nc" id="L448">                      toReplace = unwrap( toReplace );</span>
                  } else {
<span class="nc" id="L450">                      throw new RuntimeException(&quot;Unreachable code reached&quot;);                          </span>
                  }
                }
                
<span class="nc" id="L454">                debugPrintln(&quot;DISTRIBUTIVE LAW: Replacing &quot;+matchedParent.toString(false)+&quot; -&gt; &quot;+replacementTerm);</span>
<span class="nc" id="L455">                toReplace.replaceWith( replacementTerm );</span>
<span class="nc" id="L456">                it.astMutated();                </span>
<span class="nc" id="L457">            }</span>
        };
<span class="nc" id="L459">        return applyInOrder( result , visitor );</span>
    }
    
    protected ASTNode maybeWrapInTerm(ASTNode node) {
<span class="nc bnc" id="L463" title="All 2 branches missed.">        if ( node.getNodeCount() == 1 ) {</span>
<span class="nc" id="L464">            return node;</span>
        }
<span class="nc" id="L466">        return new TermNode( node );</span>
    }

    public ASTNode substituteIdentifiers(ASTNode input,IExpressionContext context) {

<span class="nc" id="L471">        ASTNode result = input.createCopy( true );</span>

<span class="nc" id="L473">        final MutatingNodeVisitor visitor = new MutatingNodeVisitor(context) {</span>

            @Override
            protected void visit(ASTNode node, IExpressionContext context,
                    IIterationContext it) 
            {
<span class="nc bnc" id="L479" title="All 2 branches missed.">                if ( node instanceof IdentifierNode) </span>
                {
<span class="nc" id="L481">                    Identifier id = ((IdentifierNode) node).getIdentifier();</span>
<span class="nc" id="L482">                    ASTNode value = context.tryLookup( id );</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">                    if ( value != null ) {</span>
<span class="nc" id="L484">                        node.replaceWith( value );</span>
<span class="nc" id="L485">                        it.astMutated();</span>
                    }
                }
<span class="nc" id="L488">            }</span>
        };

<span class="nc" id="L491">        applyInOrder( result , visitor );</span>
<span class="nc" id="L492">        return result;</span>
    }

    public Set&lt;Identifier&gt; gatherIdentifiers(ASTNode node) 
    {
<span class="nc" id="L497">        final Set&lt;Identifier&gt; result = new HashSet&lt;Identifier&gt;();</span>
<span class="nc" id="L498">        INodeVisitor visitor = new INodeVisitor() {</span>

            @Override
            public boolean visit(ASTNode node, int currentDepth) 
            {
<span class="nc bnc" id="L503" title="All 2 branches missed.">                if ( node instanceof IdentifierNode) {</span>
<span class="nc" id="L504">                    result.add(( (IdentifierNode) node).getIdentifier() );</span>
                }
<span class="nc" id="L506">                return true;</span>
            }
        };
<span class="nc" id="L509">        node.visitInOrder( visitor );</span>
<span class="nc" id="L510">        return result;</span>
    }

    private boolean applyLawOfIdemPotency(final IExpressionContext context,
            ASTNode result) 
    {
        // 1. Idempotenzgesetze ( x and x = x ) / ( x or x ) = x
<span class="nc" id="L517">        final MutatingNodeVisitor visitor = new MutatingNodeVisitor( context ) {</span>

            @Override
            public void visit(ASTNode node,IExpressionContext context,IIterationContext it) 
            {
<span class="nc" id="L522">                final ASTNode unwrapped = unwrap( node );</span>
<span class="nc bnc" id="L523" title="All 6 branches missed.">                if ( unwrapped.hasParent() &amp;&amp; ( unwrapped.isAND() || unwrapped.isOR() ) ) </span>
                {
<span class="nc" id="L525">                    final boolean isEquivalent = unwrap( unwrapped.leftChild() ).isEquivalent( </span>
<span class="nc" id="L526">                            unwrap( unwrapped.rightChild() ) , context );</span>

<span class="nc bnc" id="L528" title="All 2 branches missed.">                    if ( isEquivalent ) </span>
                    {
<span class="nc" id="L530">                        debugPrintln(&quot;IDEM: Replacing &quot;+unwrapped.toString(false)+&quot; -&gt; &quot;+unwrapped.child(0).toString(false));</span>
<span class="nc" id="L531">                        unwrapped.replaceWith( unwrapped.child(0) );</span>
<span class="nc" id="L532">                        it.astMutated();</span>
                    }
                } 
<span class="nc" id="L535">            }</span>
        };
<span class="nc" id="L537">        return applyInOrder( result , visitor );</span>
    }

    private boolean applyRuleOfDoubleNegation(final IExpressionContext context,
            ASTNode result) 
    {
        // double negation: Doppelnegationsgesetz =&gt; not( not a)=a
<span class="nc" id="L544">        final MutatingNodeVisitor visitor2 = new MutatingNodeVisitor( context ) {</span>

            @Override
            public void visit(ASTNode node,IExpressionContext context,IIterationContext it) 
            {
<span class="nc" id="L549">                final ASTNode unwrapped = unwrap( node );</span>
<span class="nc bnc" id="L550" title="All 4 branches missed.">                if ( unwrapped.hasParent() &amp;&amp; unwrapped.isNOT() ) </span>
                {
<span class="nc bnc" id="L552" title="All 2 branches missed.">                    if ( unwrap( unwrapped.leftChild() ).isNOT() ) </span>
                    {
<span class="nc" id="L554">                        debugPrintln(&quot;NOT-NOT: Replacing &quot;+unwrapped.toString(false)+</span>
<span class="nc" id="L555">                                &quot; -&gt; &quot;+unwrapped.leftChild().leftChild().toString(false));</span>
<span class="nc" id="L556">                        unwrapped.replaceWith( unwrap( unwrapped.leftChild() ).leftChild() );</span>
<span class="nc" id="L557">                        it.astMutated();</span>
                    }
                } 
<span class="nc" id="L560">            }</span>
        };

<span class="nc" id="L563">        return applyInOrder( result , visitor2 );</span>
    }

    private boolean applyLawOfIdentity(final IExpressionContext context,
            ASTNode result) 
    {
        // NeutralitÃ¤tsgesetze   =&gt; a and 1 = a 	
        //                       =&gt; a or 0 = a		
<span class="nc" id="L571">        final MutatingNodeVisitor visitor3 = new MutatingNodeVisitor( context ) {</span>

            @Override
            public void visit(ASTNode node,IExpressionContext context,IIterationContext it) 
            {
<span class="nc" id="L576">                final ASTNode unwrapped = unwrap( node );</span>
<span class="nc bnc" id="L577" title="All 6 branches missed.">                if ( unwrapped.hasParent() &amp;&amp; ( unwrapped.isOR() || unwrapped.isAND() ) ) </span>
                {
<span class="nc" id="L579">                    final ASTNode leftChild = unwrap( unwrapped.child(0) );</span>
<span class="nc" id="L580">                    final ASTNode rightChild = unwrap( unwrapped.child(1) );</span>

<span class="nc bnc" id="L582" title="All 2 branches missed.">                    final ASTNode neutralElement = unwrapped.isAND() ? new TrueNode() : new FalseNode();</span>

<span class="nc bnc" id="L584" title="All 2 branches missed.">                    if ( leftChild.isEquivalent( neutralElement , context) ) </span>
                    {
<span class="nc" id="L586">                        debugPrintln(&quot;IDENTITY: Replacing &quot;+unwrapped.toString(false)+</span>
                                &quot; -&gt; &quot;+rightChild);
<span class="nc" id="L588">                        unwrapped.replaceWith( rightChild );</span>
<span class="nc" id="L589">                        it.astMutated();						</span>
                    } 
<span class="nc bnc" id="L591" title="All 2 branches missed.">                    else if ( rightChild.isEquivalent( neutralElement , context ) ) </span>
                    {
<span class="nc" id="L593">                        debugPrintln(&quot;NEUTRALITY: Replacing &quot;+unwrapped.toString(false)+</span>
                                &quot; -&gt; &quot;+leftChild);						
<span class="nc" id="L595">                        unwrapped.replaceWith( leftChild );</span>
<span class="nc" id="L596">                        it.astMutated();</span>
                    }
                } 
<span class="nc" id="L599">            }</span>
        };

<span class="nc" id="L602">        return applyInOrder( result , visitor3 );</span>
    }

    private boolean applyLawOfExtrema(final IExpressionContext context,
            ASTNode result) 
    {
        // Extremalgesetze 	  =&gt; a and 0=0 	
        //                    =&gt; a or 1=1				
<span class="nc" id="L610">        final MutatingNodeVisitor visitor4 = new MutatingNodeVisitor( context ) {</span>

            @Override
            public void visit(ASTNode node,IExpressionContext context,IIterationContext it) 
            {
<span class="nc" id="L615">                final ASTNode unwrapped = unwrap( node );</span>
<span class="nc bnc" id="L616" title="All 6 branches missed.">                if ( unwrapped.hasParent() &amp;&amp; ( unwrapped.isOR() || unwrapped.isAND() ) ) </span>
                {
<span class="nc" id="L618">                    final ASTNode leftChild = unwrap( unwrapped.child(0) );</span>
<span class="nc" id="L619">                    final ASTNode rightChild = unwrap( unwrapped.child(1) );</span>

<span class="nc bnc" id="L621" title="All 2 branches missed.">                    final ASTNode neutralElement = unwrapped.isAND() ? new FalseNode() : new TrueNode();</span>

<span class="nc bnc" id="L623" title="All 2 branches missed.">                    if ( leftChild.isEquivalent( neutralElement , context) ) </span>
                    {
<span class="nc" id="L625">                        debugPrintln(&quot;EXTREMES: Replacing &quot;+unwrapped.toString(false)+</span>
                                &quot; -&gt; &quot;+rightChild);
<span class="nc" id="L627">                        unwrapped.replaceWith( neutralElement );</span>
<span class="nc" id="L628">                        it.astMutated();						</span>
                    } 
<span class="nc bnc" id="L630" title="All 2 branches missed.">                    else if ( rightChild.isEquivalent( neutralElement , context ) ) </span>
                    {
<span class="nc" id="L632">                        debugPrintln(&quot;NEUTRALITY: Replacing &quot;+unwrapped.toString(false)+</span>
                                &quot; -&gt; &quot;+leftChild);						
<span class="nc" id="L634">                        unwrapped.replaceWith( neutralElement );</span>
<span class="nc" id="L635">                        it.astMutated();</span>
                    }
                } 
<span class="nc" id="L638">            }</span>
        };

<span class="nc" id="L641">        return applyInOrder( result , visitor4 );</span>
    }

    private boolean applyLawOfComplements(final IExpressionContext context,
            ASTNode result) 
    {
        // KomplementÃ¤rgesetze   =&gt; a and not a=0 	
        //                       =&gt; a or not a=1		 
<span class="nc" id="L649">        final MutatingNodeVisitor visitor5 = new MutatingNodeVisitor( context ) {</span>

            @Override
            public void visit(ASTNode node,IExpressionContext context,IIterationContext it) 
            {
<span class="nc" id="L654">                final ASTNode unwrapped = unwrap( node );</span>
<span class="nc bnc" id="L655" title="All 6 branches missed.">                if ( unwrapped.hasParent() &amp;&amp; ( unwrapped.isOR() || unwrapped.isAND() ) ) </span>
                {
<span class="nc" id="L657">                    final ASTNode leftChild = unwrap( unwrapped.child(0) );					</span>
<span class="nc" id="L658">                    final ASTNode rightChild = unwrap( unwrapped.child(1) );</span>

<span class="nc bnc" id="L660" title="All 2 branches missed.">                    if ( rightChild.isNOT() ) </span>
                    {
<span class="nc" id="L662">                        ASTNode subTerm = unwrap( rightChild.child(0) );</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">                        if ( subTerm.isEquals( leftChild) )</span>
                        { 
<span class="nc bnc" id="L665" title="All 2 branches missed.">                            final ASTNode result = unwrapped.isAND() ? new FalseNode() : new TrueNode();</span>

<span class="nc" id="L667">                            debugPrintln(&quot;COMPLEMENTS: Replacing &quot;+unwrapped.toString(false)+</span>
                                    &quot; -&gt; &quot;+result);
<span class="nc" id="L669">                            unwrapped.replaceWith( result );</span>
<span class="nc" id="L670">                            it.astMutated();			</span>
                        }
                    } 
                } 
<span class="nc" id="L674">            }</span>
        };

<span class="nc" id="L677">        return applyInOrder( result , visitor5);</span>
    }

    private boolean applyLawOfAbsorption(final IExpressionContext context,
            ASTNode result) 
    {
        // Absorptionsgesetze 	 =&gt; a or (a and b) = a 	
        //                       =&gt; a and(a or  b) = a			
<span class="nc" id="L685">        final MutatingNodeVisitor visitor6 = new MutatingNodeVisitor( context ) {</span>

            @Override
            public void visit(ASTNode node,IExpressionContext context,IIterationContext it) 
            {
<span class="nc" id="L690">                final ASTNode unwrapped = unwrap( node );</span>
<span class="nc bnc" id="L691" title="All 6 branches missed.">                if ( unwrapped.hasParent() &amp;&amp; ( unwrapped.isOR() || unwrapped.isAND() ) ) </span>
                {
<span class="nc" id="L693">                    final ASTNode leftChild = unwrap( unwrapped.child(0) );					</span>
<span class="nc" id="L694">                    final ASTNode rightChild = unwrap( unwrapped.child(1) );</span>

<span class="nc bnc" id="L696" title="All 4 branches missed.">                    if ( ( ( unwrapped.isOR()  &amp;&amp; rightChild.isAND() ) ||</span>
<span class="nc bnc" id="L697" title="All 4 branches missed.">                            ( unwrapped.isAND() &amp;&amp; rightChild.isOR()  ) ) ) </span>
                    {
<span class="nc" id="L699">                        ASTNode subTerm = unwrap( rightChild.child(0) );</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">                        if ( subTerm.isEquals( leftChild) ) </span>
                        { 
<span class="nc" id="L702">                            debugPrintln(&quot;ABSORPTION: Replacing &quot;+unwrapped.toString(false)+</span>
                                    &quot; -&gt; &quot;+leftChild);
<span class="nc" id="L704">                            unwrapped.replaceWith( leftChild );</span>
<span class="nc" id="L705">                            it.astMutated();			</span>
                        }
                    } 
                } 
<span class="nc" id="L709">            }</span>
        };

<span class="nc" id="L712">        return applyInOrder( result , visitor6 );</span>
    }

    private boolean applyLawOfDeMorgan(IExpressionContext context,ASTNode result) 
    {
        // De Morgansche Gesetze  =&gt; not(a and b) = not a or  not b 	
        //                        =&gt; not(a or  b) = not a and not b
<span class="nc" id="L719">        final MutatingNodeVisitor visitor6 = new MutatingNodeVisitor( context ) {</span>

            @Override
            public void visit(ASTNode node,IExpressionContext context,IIterationContext it) 
            {
<span class="nc" id="L724">                final ASTNode unwrapped = unwrap( node );</span>
<span class="nc bnc" id="L725" title="All 4 branches missed.">                if ( unwrapped.isNOT() &amp;&amp; unwrapped.hasParent()  )</span>
                {
<span class="nc" id="L727">                    final ASTNode child = unwrap( unwrapped.child(0) );</span>
<span class="nc bnc" id="L728" title="All 4 branches missed.">                    if ( ( child.isAND() || child.isOR() ) ) </span>
                    {
<span class="nc" id="L730">                        final ASTNode leftChild = unwrap( child.child(0) );					</span>
<span class="nc" id="L731">                        final ASTNode rightChild = unwrap( child.child(1) );</span>

<span class="nc" id="L733">                        final ASTNode notLeft = OperatorNode.not( leftChild.createCopy(true) );</span>
<span class="nc" id="L734">                        final ASTNode notRight = OperatorNode.not( rightChild.createCopy(true) );</span>

<span class="nc bnc" id="L736" title="All 2 branches missed.">                        final ASTNode newTerm = child.isAND() ? </span>
<span class="nc" id="L737">                                OperatorNode.or( notLeft , notRight ) :</span>
<span class="nc" id="L738">                                    OperatorNode.and( notLeft , notRight );</span>

<span class="nc" id="L740">                                debugPrintln(&quot;DE-MORGAN: Replacing &quot;+unwrapped.toString(false)+</span>
                                        &quot; -&gt; &quot;+newTerm);
<span class="nc" id="L742">                                unwrapped.replaceWith( newTerm );</span>
<span class="nc" id="L743">                                it.astMutated();			</span>
                    }
                } 
<span class="nc" id="L746">            }</span>
        };

<span class="nc" id="L749">        return applyInOrder( result , visitor6 );		</span>
    }

    private boolean applyInverseLawOfDeMorgan(IExpressionContext context,ASTNode result) 
    {
        // De Morgansche Gesetze  =&gt; not a or  not b = not(a and b)   	
        //                        =&gt; not a and not b = not(a or  b) 

<span class="nc" id="L757">        final MutatingNodeVisitor visitor6 = new MutatingNodeVisitor( context ) {</span>

            @Override
            public void visit(ASTNode node,IExpressionContext context,IIterationContext it) 
            {
<span class="nc" id="L762">                final ASTNode unwrapped = unwrap( node );</span>
<span class="nc bnc" id="L763" title="All 6 branches missed.">                if ( unwrapped.hasParent() &amp;&amp; ( unwrapped.isOR() || unwrapped.isAND() ) )</span>
                {
<span class="nc" id="L765">                    final ASTNode leftChild = unwrap( unwrapped.child(0) );					</span>
<span class="nc" id="L766">                    final ASTNode rightChild = unwrap( unwrapped.child(1) );</span>

<span class="nc bnc" id="L768" title="All 4 branches missed.">                    if ( (leftChild.isNOT() &amp;&amp; rightChild.isNOT() ) ) </span>
                    {
<span class="nc" id="L770">                        final ASTNode leftArgument = unwrap( leftChild.child(0 ) );</span>
<span class="nc" id="L771">                        final ASTNode rightArgument = unwrap( rightChild.child( 0 ) );</span>

                        final ASTNode newTerm;
<span class="nc bnc" id="L774" title="All 2 branches missed.">                        if ( unwrapped.isOR() ) {</span>
<span class="nc" id="L775">                            newTerm = OperatorNode.not( </span>
<span class="nc" id="L776">                                    OperatorNode.and( leftArgument.createCopy(true) ,</span>
<span class="nc" id="L777">                                            rightArgument.createCopy(true) ) );</span>
                        } else { // AND
<span class="nc" id="L779">                            newTerm = OperatorNode.not( </span>
<span class="nc" id="L780">                                    OperatorNode.or( leftArgument.createCopy(true) ,</span>
<span class="nc" id="L781">                                            rightArgument.createCopy(true) ) );							</span>
                        }
<span class="nc" id="L783">                        debugPrintln(&quot;INV. DE-MORGAN: Replacing &quot;+unwrapped.toString(false)+</span>
                                &quot; -&gt; &quot;+newTerm);
<span class="nc" id="L785">                        unwrapped.replaceWith( newTerm );</span>
<span class="nc" id="L786">                        it.astMutated();			</span>
                    }
                } 
<span class="nc" id="L789">            }</span>
        };

<span class="nc" id="L792">        return applyInOrder( result , visitor6 );		</span>
    }	

    protected static ASTNode unwrap(ASTNode node) 
    {
<span class="nc" id="L797">        ASTNode result = node;</span>
<span class="nc bnc" id="L798" title="All 4 branches missed.">        while ( result instanceof TermNode &amp;&amp; result.hasChildren() ) {</span>
<span class="nc" id="L799">            result = result.child(0);</span>
        }
<span class="nc" id="L801">        return result;</span>
    }

    /**
     * Tries to reduce a term by replacing expressions that
     * evaluate to a literal value (true or false) with the corresponding value.
     * 
     * @param term
     * @param context
     * @return
     */
    public ASTNode reduce(ASTNode term,final IExpressionContext context) 
    {
<span class="nc bnc" id="L814" title="All 2 branches missed.">        if ( term instanceof BooleanExpression) </span>
        {
<span class="nc" id="L816">            final BooleanExpression expr = (BooleanExpression) term;</span>
<span class="nc" id="L817">            ASTNode left = internalReduce( expr.getLHS() , context );</span>
<span class="nc" id="L818">            ASTNode right = internalReduce( expr.getRHS() , context );</span>
<span class="nc" id="L819">            return new BooleanExpression( left , right );</span>
        } 
<span class="nc" id="L821">        return internalReduce( term , context );        </span>
    }

    protected ASTNode internalReduce(ASTNode term,final IExpressionContext context) 
    {
<span class="nc" id="L826">        final ASTNode result = term.createCopy( true );</span>

<span class="nc" id="L828">        final MutatingNodeVisitor visitor = new MutatingNodeVisitor( context ) {</span>

            @Override
            public void visit(ASTNode node,IExpressionContext context,IIterationContext it) 
            {
<span class="nc bnc" id="L833" title="All 2 branches missed.">                if ( node.hasParent() ) </span>
                {
<span class="nc bnc" id="L835" title="All 4 branches missed.">                    if ( node instanceof IdentifierNode &amp;&amp; ! node.hasLiteralValue( context ) ) {</span>
<span class="nc" id="L836">                        return;</span>
                    }

<span class="nc" id="L839">                    final ASTNode reduced = node.evaluate( context );</span>
<span class="nc" id="L840">                    debugPrintln(&quot;REDUCE: &quot;+node+&quot; evaluates to &quot;+reduced);                    </span>
<span class="nc bnc" id="L841" title="All 6 branches missed.">                    if ( reduced != null &amp;&amp; reduced != node &amp;&amp; reduced != unwrap( node ) )</span>
                    {
<span class="nc" id="L843">                        debugPrintln(&quot;REDUCE: Replacing &quot;+node+&quot; -&gt; &quot;+reduced);</span>
<span class="nc" id="L844">                        node.replaceWith( reduced );</span>
<span class="nc" id="L845">                        it.astMutated();</span>
<span class="nc" id="L846">                        it.stop();</span>
                    } 
                }
<span class="nc" id="L849">            }</span>
        };

<span class="nc" id="L852">        applyPostOrder( result , visitor );</span>
<span class="nc" id="L853">        return result;</span>
    }

    public ASTNode expand(ASTNode term,IExpressionContext context,boolean deleteExpandedVars) 
    {
<span class="nc" id="L858">        final ASTNode result = term.createCopy( true );</span>

<span class="nc" id="L860">        final Set&lt;Identifier&gt; expandedIdentifiers = new HashSet&lt;&gt;();</span>

<span class="nc" id="L862">        boolean expanded = false;</span>
        do 
        {
<span class="nc" id="L865">            expanded = false;</span>
<span class="nc" id="L866">            final MutatingNodeVisitor visitor = new MutatingNodeVisitor( context ) {</span>

                @Override
                public void visit(ASTNode node,IExpressionContext context,IIterationContext it) 
                {
<span class="nc" id="L871">                    final ASTNode unwrapped = unwrap( node );</span>
<span class="nc bnc" id="L872" title="All 4 branches missed.">                    if ( node.hasParent() &amp;&amp; unwrapped instanceof IdentifierNode ) </span>
                    {
<span class="nc" id="L874">                        final ASTNode expanded = unwrapped.evaluate( context );</span>
<span class="nc bnc" id="L875" title="All 4 branches missed.">                        if ( expanded != null &amp;&amp; expanded != unwrapped )</span>
                        {
<span class="nc" id="L877">                            debugPrintln(&quot;EXPAND: Expanding &quot;+node+&quot; -&gt; &quot;+expanded);</span>
<span class="nc" id="L878">                            expandedIdentifiers.add( ((IdentifierNode) unwrapped).getIdentifier() );</span>
<span class="nc" id="L879">                            node.replaceWith( expanded );</span>
<span class="nc" id="L880">                            it.astMutated();</span>
                        } 
                    }
<span class="nc" id="L883">                }</span>
            };

<span class="nc" id="L886">            expanded = applyPostOrder( result , visitor );</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">        } while ( expanded );</span>

<span class="nc bnc" id="L889" title="All 2 branches missed.">        if ( deleteExpandedVars ) {</span>
<span class="nc bnc" id="L890" title="All 2 branches missed.">            for ( Identifier id : expandedIdentifiers ) {</span>
<span class="nc" id="L891">                context.remove( id );</span>
<span class="nc" id="L892">            }</span>
        }

<span class="nc" id="L895">        return result;</span>

    }

    public ASTNode eval(ASTNode term,IExpressionContext context) {
<span class="nc" id="L900">        return reduce( term , context);</span>
    }

    protected static boolean applyInOrder(ASTNode term,MutatingNodeVisitor visitor) {
        do {
<span class="nc" id="L905">            term.visitInOrder( visitor );</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">        } while ( visitor.isASTMutated() );</span>
<span class="nc bnc" id="L907" title="All 2 branches missed.">        return visitor.getMutationCount() &gt; 0;</span>
    }	

    protected static boolean applyPostOrder(ASTNode term,MutatingNodeVisitor visitor) {
        do {
<span class="nc" id="L912">            term.visitPostOrder( visitor );</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">        } while ( visitor.isASTMutated() );</span>
<span class="nc bnc" id="L914" title="All 2 branches missed.">        return visitor.getMutationCount() &gt; 0;</span>
    }	

    protected static boolean applyPreOrder(ASTNode term,MutatingNodeVisitor visitor) {
        do {
<span class="nc" id="L919">            term.visitPreOrder( visitor );</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">        } while ( visitor.isASTMutated() );</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">        return visitor.getMutationCount() &gt; 0;</span>
    }		

    protected static abstract class MutatingNodeVisitor implements INodeVisitor {

        private final IExpressionContext context;

<span class="nc" id="L928">        private boolean stop= false;</span>
<span class="nc" id="L929">        private boolean astMutated = false;</span>

<span class="nc" id="L931">        private int mutationCount = 0;</span>
<span class="nc" id="L932">        private final IIterationContext it = new IIterationContext() {</span>

            @Override
            public void stop() {
<span class="nc" id="L936">                stop = true;</span>
<span class="nc" id="L937">            }</span>

            @Override
            public void astMutated() {
<span class="nc" id="L941">                mutationCount++;</span>
<span class="nc" id="L942">                astMutated = true;</span>
<span class="nc" id="L943">            }</span>
        };		

        public int getMutationCount() {
<span class="nc" id="L947">            return mutationCount;</span>
        }

        public MutatingNodeVisitor(IExpressionContext context) 
<span class="nc" id="L951">        {</span>
<span class="nc bnc" id="L952" title="All 2 branches missed.">            if (context == null) {</span>
<span class="nc" id="L953">                throw new IllegalArgumentException(&quot;context must not be null&quot;);</span>
            }
<span class="nc" id="L955">            this.context = context;</span>
<span class="nc" id="L956">        }</span>

        public boolean isASTMutated() {
<span class="nc" id="L959">            return astMutated;</span>
        }

        @Override
        public final boolean visit(ASTNode node, int currentDepth) 
        {
<span class="nc" id="L965">            stop = false;</span>
<span class="nc" id="L966">            astMutated = false;</span>
<span class="nc" id="L967">            visit( node , context , it );</span>
<span class="nc bnc" id="L968" title="All 2 branches missed.">            return ! stop;</span>
        }

        protected abstract void visit(ASTNode node,IExpressionContext context,IIterationContext it);
    }

    public static abstract class TreeMatchingVisitor extends MutatingNodeVisitor {

        private final TreeMatcher matcher;

        public TreeMatchingVisitor(IExpressionContext context,TreeMatcher matcher) {
<span class="nc" id="L979">            super( context );</span>
<span class="nc" id="L980">            this.matcher = matcher;</span>
<span class="nc" id="L981">        }</span>

        @Override
        protected void visit(ASTNode node, IExpressionContext context, IIterationContext it)
        {
<span class="nc bnc" id="L986" title="All 2 branches missed.">            if ( matcher.matches( matcher, node ) ) {</span>
<span class="nc bnc" id="L987" title="All 2 branches missed.">                if ( onMatch( matcher , context ) ) {</span>
<span class="nc" id="L988">                    it.astMutated();</span>
                }
            }
<span class="nc" id="L991">        }</span>

        protected abstract boolean onMatch(TreeMatcher matcher,IExpressionContext context);
    }

    private void debugPrintln(String message) {
<span class="nc bnc" id="L997" title="All 2 branches missed.">        if ( debug ) {</span>
<span class="nc" id="L998">            System.out.println( message );</span>
        }
<span class="nc" id="L1000">    }</span>

    private void debugPrint(String message) {
<span class="nc bnc" id="L1003" title="All 2 branches missed.">        if ( debug ) {</span>
<span class="nc" id="L1004">            System.out.print( message );</span>
        }
<span class="nc" id="L1006">    }</span>

    public void setDebug(boolean yesNo) {
<span class="nc" id="L1009">        this.debug = yesNo;</span>
<span class="nc" id="L1010">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>